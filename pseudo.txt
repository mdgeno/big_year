-ask the user for input '?'

-the program recognises the below commands;
	add 	- adds a bird, then proceeds to;
		- ask user to input 'Name: '
		- ask user to input 'Name in Latin: '

		-take in the name inputs and create a bird object
			then store it in the bird array.

	spotted - adds a sighting
		- if not in database of birds, the program then
			outputs 'Not a bird!'		

	all 	- prints all birds
		- outputs all birds and displays information
			'NameOfBird (Latin Name): number of sightings

	one 	- prints one bird
		- asks the user 'Bird?', takes in the string value
			representing the name of the bird.
		- then outputs the full information of the 
			single bird which the name was entered.
			(format the same from All command)
		
	quit - ends the program


-complete the use documentation of diagram/use case scenario.

                  Main/UI
		/	  \
	    backend  --	 game
		|
	     database
 <OK>

CONTINUE HERE!
-try to continue implementing functions with the spotted commands<OK> and 
 one commands.
-when making it user interactive take note of the sightings field of the
 bird object, to be automatically set to 0 initially.


=============================================
-struct BirdArray
	array: [Bird; 5]
	
	impl BirdArray
		add
		one
		all
 
+

-struct Bird
	name: 
	name in latin
	mut sighting
	
	impl Bird
		print

OR 

-enum BirdDatabase
	Bird{ name:
	      latin_name:
	      sighting:
	    }
	BirdArray{array: [Bird; 5]} or??
	BirdArray([Bird; 5])

	impl BirdDatabase
		add
		one
		all
		spotted

??


-So an array of Bird objects is possible. We now just have to find
a way to create a series of Bird objs through a loop construct,
and simultaneously store it in the array of Bird objs.

LATEST CONCLUSION
-It is very difficult for my current level to be able to code a 
concept of a database for birds. My knowledge is currently limited
to only tuples and arrays for collections constructs. I've researched
for solutions, work arounds, and it has always been advised to use
vecotrs for these types of scenarios, which I will be tackling on
very soon.
-The limitations I came to realise are that arrays have a fixed
size, although I compromised with proceeding with an array length
of 5 values.
-Another limitation is creating an Array of objects. When
instantiating an array, it is necessary that there be values filled
in each index, for instance an array of integers need to have atleast
0s althrough out the index to represent an empty array. The 
limitation is that creating an empty array of Bird objects is
somewhat not doable as the program handles different commands during
runtime and adding a bird obj in to the array is only one of them.
Therefore, an array with empty slots is really necessary to 
satisfy the required features of the program.
-I shall resume this program as soon as I have gained the vector
ability.
-(UPDATE as of: Nov 5 2025) I was able to create an empty array or
atleast an idea of an array that represents an empty array of Bird Struct objects.
This was purely from information gathered from the compiler error
displaying information about some types such as Strings do not implement
the Copy trait, which as well allowed me to discover additional
information by looking through the Copy trait rust official 
documentation, which then led me to learn about a line of code/algorithm
that would allow objects such as String Structs, or the modified types
such as the Bird Struct type, to be cloned in an initialised array 
and to represent the cloned values as empty values. 
	-however, I was at a halt from this point as when proceeding
	towards the next steps of creating a new array with an 
	increased size, I am not able to make rust recognise the 
	increased value that I give to the new array with increased
	size that I was trying to initialize. 




